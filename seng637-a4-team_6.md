**SENG 637 - Dependability and Reliability of Software Systems**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:6     |     |
| -------------- | --- |
| Student Names: |     |
| Sean Temple    |     |
| John Chernoff               |     |
| Nicholas Langley               |     |
| Raisa Mehjabin Azni            |   
| Eric Yoon            |   


### 2.5.6 Equivalent Mutants

Try to come up with a way that you could automatically detect a few equivalent mutants in your experimentation, for classes `Range` and `DataUtilities`. If you think you have found a way, discuss it in your report, along with its benefits, disadvantages, and assumptions. Try to detect a few equivalent mutants manually in classes `Range` and `DataUtilities` (to do this, you will need to investigate the mutation logs generated by the tool).
Report the process you followed for this part plus your findings and results in your lab report. Note that the number of equivalent mutants found is not as important as the understanding of how to detect them and the discussion of how you found them.

### 2.5.7 Add More Test Cases to increase Mutation Score

In this phase, we want to increase the mutation score. For each of the classes under mutation testing (`Range` and `DataUtilities`), measure the mutation score of your original test suites from assignment 3. Aim at increasing mutation scores for `Range` and `DataUtilities` each by at least <span style="color:green">10% <span style="color:black">, e.g., if it is <span style="color:green">55%<span style="color:black">, make it at least<span style="color:green"> 65%<span style="color:black">. Discuss in your report the test cases that you had to add to increase the mutation score, and also how you designed them.

# Introduction

# Analysis of 10 Mutants of the Range class 

**Constrain mutants:**
 
 *1. constrain : Incremented (a++) double local variable number 1 -> Survived*
 
 This mutant survives, primarily because there are no tests for constrain where value is very close to the edge of the range
 
 **Relevant code** 
 ```
 double result = value;  // value is incremented AFTER being assigned to result (value++)  
    if (!contains(value)) {    // if value was increased from within range to out of range, these conditional statements would behave differently and the mutant would be killed.    
		if (value > this.upper)     
```   
Since no tests exhibit this change in behaviour due to the increment, the mutant survives. The current tests at upper bound do not catch this since the out of range value is just constrained back to the expected upper bound value.  
This is a good example for the importance of testing values very near to the boundary values   

A similar mutant exists for the post decrement (a--) behaviours near the lower bound  

<br /><br />

*2. constrain : removed conditional - replaced equality check with true -> SURVIVED*  
 
**Relevant code**    
```
if (!contains(value)) {  //this is the if statement being replaced with TRUE --- if (TRUE)    
            if (value > this.upper) {  //only runs if the above conditional is true    
                result = this.upper;    
            }    
            else if (value < this.lower) { //else if... also can only run if the parent conditional is true    
                result = this.lower;    
            }    
        }
```	
This mutant survives, because the enclosed if statements also implicitly check that the value is within the range. If the value is out of range but gets to these checks anyway (due to the mutant), nothing happens.
As a result this mutant cannot be killed without changing the actual code to be less robust(for example changing the child if statements to end with 'else').

The opposite mutant (replacing conditional with FALSE) is correctly killed as it prevents the interior code from ever running

<br /><br />

*3. constrain : Negated double field upper -> SURVIVED*    
    
**Relevant code**   
```
            if (value > this.upper) {  //Negated value here --- if (value > -1*this.upper)    
                result = this.upper;    
            }    
```   
This mutant survives because there is only 1 test that could be affected by this mutant but the effect is barely missed    
the test is as follows range(-10, 20) and constrained value is -22.    
Since the input value is still lower than the negated upper value (-20), the test was unaffected and the mutant survived    
    
Adding tests with similar equivalence classes but differing values would kill more mutants like this. Increasing the diversity of the tests at the cost taking more time to implement and run them    

**getLength Mutants:**
   
*4. getLength: Replaced double subtraction with addition → KILLED*

This mutant is killed because the test cases for getLength expect specific values based on the subtracted values. By replacing subtraction with addition the results produced are significantly incorrect and easily detected by the test cases.

**Relevant code**   
```
    public double getLength() {
        return this.upper - this.lower; //Replacing '-' with '+' here produces significantly incorrect results which are detected by test cases.
    }
```  

*5. getLength: Replaced double subtraction with multiplication → KILLED*

This mutant is killed because the test cases for getLength expect specific values based on the subtracted values. Similarly to the previous mutant, by replacing subtraction with multiplication the results produced are quite different than the correct values, and easily detected by the test cases. 

**Relevant code**   
```
    public double getLength() {
        return this.upper - this.lower; //Replacing '-' with '*' here produces significantly incorrect results which are detected by test cases.
    }
```  

*6. getLength: Incremented (a++) double field lower → SURVIVED*

This mutant survived, likely because the test cases are rounding or don't assert values with high precision. There also aren't any direct tests that assert the change in length due to a single increment of the lower bound, adding such a test case would kill this mutant.

**Relevant code**   
```
    public double getLength() {
        return this.upper - this.lower; //Incrementing the lower bound here (lower++) can affect the result, depending on the sensitivity of tests to the incremented amount.
    }
```  

**getCentralValue mutants:**

![](media/RangegetCentralValue.png)
> getCentralValue() is a single statement method.
![](media/RangegetCentralValueMutants.png)
> 47 different mutations applied to this single line.
> - Mutation type 1 substituted the values 2.0 with 1.0 (Mutation 1, 2, 28, 29, 38, 39): Replaces the constant 2.0 with 1.0 in the expression this.lower / 2.0 + this.upper / 2.0. This type of mutation was always detected by the test suite meaning it triggered a test failure and was "KILLED". It makes sense that it would be detected as it changes the expression in a way that cause a incorrect value to be returned.
> - Mutation type 2 replaced math operators with different operations. (Mutations 3, 4, 5, 16, 17, 18): For the same reasons as the first type the return value will be incorrect and the test will fail. 
> - Mutation type 3 replaces the math expression with 0.0d (Mutation 6): Any test expecting a value of 0.0 may pass but the rest fail causing the Mutation to be killed.
> - Mutation type 4 replaces the math expression x with -(x-1). (Mutation 7) example: 
> 
> return this.lower / 2.0 + this.upper / 2.0;
> 
> becomes:
> 
> return -(this.lower / 2.0 + this.upper / 2.0 + 1);
> 
> The wrong value will be returned and caught by the Junit test killing the Mutation.
> - Most of the rest of the tests follow a similar pattern causing return value to be incorrect; except for the postfix operation mutations(Mutations 40, 41, 42, 43):
> 
> This is because the postfix operator doesn't change the upper and lower values until after the upper and lower values are used in the math expression. The return value is unaffected so all tests pass. 
> 
> The value of lower and upper are incremented in the function when they shouldn't be. In C++ the method could be made const preventing writing to member variables, not sure solution here? just create a test that upper and lower member variables are unchanged from start of method?




# Report all the statistics and the mutation score for each test class
NOTE: These values include the methods that are not covered by any test cases

RangeSample:
![](./media/25-rangesample.PNG)

DataUtilitiesSample:
![](./media/24-datasample.PNG)

ComperableObjectItem:
![](./media/13-comperableobjectitem.PNG)

ComperableObjectSeries:
![](./media/14-comperableobjectseries.PNG)

DefaultKeyedValues2D:
![](./media/15-defaultkeyedvalues2D.PNG)

DefaultKeyedValues:
![](./media/16-defaultkeyedvalues.PNG)

DefaultKeyedValue:
![](./media/17-defaultkeyedvalue.PNG)

DomainOrder:
![](./media/18-domainorder.PNG)

KeyedObjects2D:
![](./media/19-keyedobjects2D.PNG)

KeyedObjects:
![](./media/20-keyedobjects.PNG)

KeyedObject:
![](./media/21-keyedobject.PNG)

KeyToGroupMap:
![](./media/22-keytogroupmap.PNG)

RangeType:
![](./media/23-rangetype.PNG)

Range:
![](./media/10-RangeMutations.png)

DataUtilities:
![](./media/11-DataUtilitiesMutations.png)

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

Mutants are considered equivalent if they don't introduce detectable faults that can be caught by a test suite. To detect mutants entirely automatically would be quite difficult since there is no functionality within PIT or Stryker to do this. However, a combination of manual inspection and automated detection can be used to find equivalent mutants through the following steps:

1. Run the mutation and filter out all killed mutants, since killed mutants cannot be equivalent.
2. Look at each survived mutant and examine it thoroughly, find if the mutant could ever lead to a different output or side effect under any input conditions. If the mutant never leads to a different output, its equivalent.
3. Check if the mutated operation is critical for the method's outcome, or if it has no effect on observable behavior but is involved in background computations. If it does have an effect on observable behavior but produces the same outcome as the non mutated operation, it is equivalent.

A benefit of this strategy is that test coverage and quality will be improved as equivalent mutants are killed. Furthermore, this process will help the tester gain a depper understanding of the codebase. Disadvantages of this approach include its high complexity and time comsumption to complete. The strategy assumes that the test suite is complete and can detect non-equivalent mutants, while it also assumes the tester has a good understanding of the program's behavior.

**Equivalent Mutants in Range**

Mutation 91-5 (Survived): Negated double local variable number 1.

Mutation 91-6 (Survived): Incremented (a++) double local variable number 1.

Mutation 91-7 (Survived): Decremented (a--) double local variable number 1.

These mutations involve arithmetic operations on double variables and all survived, indicating that the test suite might not be effectively checking the results of such operations due to a lack of assert statements specifically targeting the effects of these arithmetic manipulations or the presence of values that do not significantly affect the outcome in a way that the tests can detect.

**Equivalent Mutants in DataUtilities**

Mutation 155-3 (Survived): removed conditional - replaced comparison check with true.

Mutation 155-4 (Survived): greater or equal to equal.

Mutation 155-9 (Survived): greater or equal to greater than.

These mutations are equivalent because they all involve alterations to conditional logic that affect how decisions are made in the code, and they all survived. They demonstrate that the tests do not adequately cover scenarios where these conditional checks are manipulated, potentially indicating areas where the test coverage could be improved.

# A discussion of what could have been done to improve the mutation score of the test suites

![](./media/RangeResultsAftercheckReadOnly.png)
Results after adding checks for read only methods altering lower and upper.

Add check for member var manipulation in methods that should be read only. (done for getCentralValue) add 1% to mut cover and 3% to test strength

Should add ths check to every read only method and might get us up 10% on its own

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the assignment itself


# 4 Evaluation Criteria

## 4.1 Lab report and Test suites (100%)

Students will be required to submit a report on their work in the lab as a group. To be consistent, please use the template markdown file “Assignment4-ReportTemplate.md” provided online under the Assignment 4 folder. If desired, feel free to rename the sections, as long as the headings are still descriptive and accurate.

<span style="color:MidnightBlue   ">**NOTE2: include folder together with your report. One containing Part 1’s final test suite, another containing Selenium test scripts.**

A portion of the grade for the lab report will be allocated to organization and clarity. The report marking scheme is as follows:

| **Mutation Testing (50)**                                                                                                                                         |     |
| --------------->>>>>>> Stashed changes-------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| Analysis of at least 10 mutants produced by Pitest for the `Range` class, and how they are killed or not by your original test suite                              | 10  |
| All the statistics and the mutation score for each of the mutated classes (`Range` and `DataUtilities`) with each test suite class (original and the updated one) | 20  |
| A discussion on the effect of equivalent mutants on mutation score accuracy including a discussion on how equivalent mutants could be detected                    | 10  |
| A discussion of how you improved the mutation score of the test suites. Your design strategy.                                                                     | 5   |
| A discussion on the advantages and disadvantages of mutation testing                                                                                              | 5   |
| **GUI Testing (40)**                                                                                                                                              |     |
| Correctness and completeness of the Recorded test cases (at least 2 per group member)                                                                             | 10  |
| Explain your test case design process                                                                                                                             | 10  |
| Use of automated verification points in each script. If automated verification point is not used, provide valid reason                                            | 10  |
| Use different test data per test. If not used, provide valid reason                                                                                               | 10  |
| **Other (10)**                                                                                                                                                     |     |
| A discussion on how the team work/effort was divided and managed. Any lessons learned from your teamwork on this lab?                                             | 5   |
|Comments/feedback on the assignment itself  | 5   |

# 5 REFERENCES

[1] J. O. Yu-Seung Ma, "Description of Class Mutation Operators for Java,"2005\.(http://cs.gmu.edu/\~offutt/mujava/mutopsClass.pdf)

[2] J. O. Yu-Seung Ma, "Description of Method-level Mutation Operators for Java," 2005. (http://cs.gmu.edu/\~offutt/mujava/mutopsMethod.pdf)

[3] "JFreeChart," Internet: <http://www.jfree.org/jfreechart> [4] "Pitest," Internet: <http://pitest.org/>
