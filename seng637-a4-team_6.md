**SENG 637 - Dependability and Reliability of Software Systems**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:6     |     |
| -------------- | --- |
| Student Names: |     |
| Sean Temple    |     |
| John Chernoff               |     |
| Nicholas Langley               |     |
| Raisa Mehjabin Azni            |   
| Eric Yoon            |   


### 2.5.6 Equivalent Mutants

Try to come up with a way that you could automatically detect a few equivalent mutants in your experimentation, for classes `Range` and `DataUtilities`. If you think you have found a way, discuss it in your report, along with its benefits, disadvantages, and assumptions. Try to detect a few equivalent mutants manually in classes `Range` and `DataUtilities` (to do this, you will need to investigate the mutation logs generated by the tool).
Report the process you followed for this part plus your findings and results in your lab report. Note that the number of equivalent mutants found is not as important as the understanding of how to detect them and the discussion of how you found them.

### 2.5.7 Add More Test Cases to increase Mutation Score

In this phase, we want to increase the mutation score. For each of the classes under mutation testing (`Range` and `DataUtilities`), measure the mutation score of your original test suites from assignment 3. Aim at increasing mutation scores for `Range` and `DataUtilities` each by at least <span style="color:green">10% <span style="color:black">, e.g., if it is <span style="color:green">55%<span style="color:black">, make it at least<span style="color:green"> 65%<span style="color:black">. Discuss in your report the test cases that you had to add to increase the mutation score, and also how you designed them.

# Introduction

# Analysis of 10 Mutants of the Range class 

**Constrain mutants:**
 
 *1. constrain : Incremented (a++) double local variable number 1 -> Survived*
 
 This mutant survives, primarily because there are no tests for constrain where value is very close to the edge of the range
 
 **Relevant code** 
 ```
 double result = value;  // value is incremented AFTER being assigned to result (value++)  
    if (!contains(value)) {    // if value was increased from within range to out of range, these conditional statements would behave differently and the mutant would be killed.    
		if (value > this.upper)     
```   
Since no tests exhibit this change in behaviour due to the increment, the mutant survives. The current tests at upper bound do not catch this since the out of range value is just constrained back to the expected upper bound value.  
This is a good example for the importance of testing values very near to the boundary values   

A similar mutant exists for the post decrement (a--) behaviours near the lower bound  

<br /><br />

*2. constrain : removed conditional - replaced equality check with true -> SURVIVED*  
 
**Relevant code**    
```
if (!contains(value)) {  //this is the if statement being replaced with TRUE --- if (TRUE)    
            if (value > this.upper) {  //only runs if the above conditional is true    
                result = this.upper;    
            }    
            else if (value < this.lower) { //else if... also can only run if the parent conditional is true    
                result = this.lower;    
            }    
        }
```	
This mutant survives, because the enclosed if statements also implicitly check that the value is within the range. If the value is out of range but gets to these checks anyway (due to the mutant), nothing happens.
As a result this mutant cannot be killed without changing the actual code to be less robust(for example changing the child if statements to end with 'else').

The opposite mutant (replacing conditional with FALSE) is correctly killed as it prevents the interior code from ever running

<br /><br />

*3. constrain : Negated double field upper -> SURVIVED*    
    
**Relevant code**   
```
            if (value > this.upper) {  //Negated value here --- if (value > -1*this.upper)    
                result = this.upper;    
            }    
```   
This mutant survives because there is only 1 test that could be affected by this mutant but the effect is barely missed    
the test is as follows range(-10, 20) and constrained value is -22.    
Since the input value is still lower than the negated upper value (-20), the test was unaffected and the mutant survived    
    
Adding tests with similar equivalence classes but differing values would kill more mutants like this. Increasing the diversity of the tests at the cost taking more time to implement and run them    
    
**getCentralValue mutants:**

![](media/RangegetCentralValue.png)
> getCentralValue() is a single statement method.
![](media/RangegetCentralValueMutants.png)
> 47 different mutations applied to this single line.
> - Mutation type 1 substituted the values 2.0 with 1.0 (Mutation 1, 2, 28, 29, 38, 39): Replaces the constant 2.0 with 1.0 in the expression this.lower / 2.0 + this.upper / 2.0. This type of mutation was always detected by the test suite meaning it triggered a test failure and was "KILLED". It makes sense that it would be detected as it changes the expression in a way that cause a incorrect value to be returned.
> - Mutation type 2 replaced math operators with different operations. (Mutations 3, 4, 5, 16, 17, 18): For the same reasons as the first type the return value will be incorrect and the test will fail. 
> - Mutation type 3 replaces the math expression with 0.0d (Mutation 6): Any test expecting a value of 0.0 may pass but the rest fail causing the Mutation to be killed.
> - Mutation type 4 replaces the math expression x with -(x-1). (Mutation 7) example: 
> 
> return this.lower / 2.0 + this.upper / 2.0;
> 
> becomes:
> 
> return -(this.lower / 2.0 + this.upper / 2.0 + 1);
> 
> The wrong value will be returned and caught by the Junit test killing the Mutation.
> - Most of the rest of the tests follow a similar pattern causing return value to be incorrect; except for the postfix operation mutations(Mutations 40, 41, 42, 43):
> 
> This is because the postfix operator doesn't change the upper and lower values until after the upper and lower values are used in the math expression. The return value is unaffected so all tests pass. 
> 
> The value of lower and upper are incremented in the function when they shouldn't be. In C++ the method could be made const preventing writing to member variables, not sure solution here? just create a test that upper and lower member variables are unchanged from start of method?




# Report all the statistics and the mutation score for each test class
NOTE: These values include the methods that are not covered by any test cases

ComperableObjectItem:
![](./media/13-comperableobjectitem.png)

ComperableObjectSeries:
![](./media/14-comperableobjectseries.png)

DefaultKeyedValues2D:
![](./media/15-defaultkeyedvalues2D.png)

DefaultKeyedValues:
![](./media/16-defaultkeyedvalues.png)

DefaultKeyedValue:
![](./media/17-defaultkeyedvalue.png)

DomainOrder:
![](./media/18-domainorder.png)

KeyedObjects2D:
![](./media/19-keyedobjects2D.png)

KeyedObjects:
![](./media/20-keyedobjects.png)

KeyedObject:
![](./media/21-keyedobject.png)

KeyToGroupMap:
![](./media/22-keytogroupmap.png)

RangeType:
![](./media/23-rangetype.png)

Range:
![](./media/10-RangeMutations.png)

DataUtilities:
![](./media/11-DataUtilitiesMutations.png)

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

# A discussion of what could have been done to improve the mutation score of the test suites

![](./media/RangeResultsAftercheckReadOnly.png)
Results after adding checks for read only methods altering lower and upper.

Add check for member var manipulation in methods that should be read only. (done for getCentralValue) add 1% to mut cover and 3% to test strength

Should add ths check to every read only method and might get us up 10% on its own

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the assignment itself


# 4 Evaluation Criteria

## 4.1 Lab report and Test suites (100%)

Students will be required to submit a report on their work in the lab as a group. To be consistent, please use the template markdown file “Assignment4-ReportTemplate.md” provided online under the Assignment 4 folder. If desired, feel free to rename the sections, as long as the headings are still descriptive and accurate.

<span style="color:MidnightBlue   ">**NOTE2: include folder together with your report. One containing Part 1’s final test suite, another containing Selenium test scripts.**

A portion of the grade for the lab report will be allocated to organization and clarity. The report marking scheme is as follows:

| **Mutation Testing (50)**                                                                                                                                         |     |
| --------------->>>>>>> Stashed changes-------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| Analysis of at least 10 mutants produced by Pitest for the `Range` class, and how they are killed or not by your original test suite                              | 10  |
| All the statistics and the mutation score for each of the mutated classes (`Range` and `DataUtilities`) with each test suite class (original and the updated one) | 20  |
| A discussion on the effect of equivalent mutants on mutation score accuracy including a discussion on how equivalent mutants could be detected                    | 10  |
| A discussion of how you improved the mutation score of the test suites. Your design strategy.                                                                     | 5   |
| A discussion on the advantages and disadvantages of mutation testing                                                                                              | 5   |
| **GUI Testing (40)**                                                                                                                                              |     |
| Correctness and completeness of the Recorded test cases (at least 2 per group member)                                                                             | 10  |
| Explain your test case design process                                                                                                                             | 10  |
| Use of automated verification points in each script. If automated verification point is not used, provide valid reason                                            | 10  |
| Use different test data per test. If not used, provide valid reason                                                                                               | 10  |
| **Other (10)**                                                                                                                                                     |     |
| A discussion on how the team work/effort was divided and managed. Any lessons learned from your teamwork on this lab?                                             | 5   |
|Comments/feedback on the assignment itself  | 5   |

# 5 REFERENCES

[1] J. O. Yu-Seung Ma, "Description of Class Mutation Operators for Java,"2005\.(http://cs.gmu.edu/\~offutt/mujava/mutopsClass.pdf)

[2] J. O. Yu-Seung Ma, "Description of Method-level Mutation Operators for Java," 2005. (http://cs.gmu.edu/\~offutt/mujava/mutopsMethod.pdf)

[3] "JFreeChart," Internet: <http://www.jfree.org/jfreechart> [4] "Pitest," Internet: <http://pitest.org/>
